name: PR Quality and Security Check

on:
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

jobs:
  code-analysis:
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Ensures we have both PR base and head for a proper diff

      - name: Gather Full Code From Changed Files
        run: |
          # List changed files from origin/main to HEAD
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)

          # Build a JSON object containing the original files
          echo '{"original files": [' > original_files_temp.json
          for file in $CHANGED_FILES; do
            # Skip .json and .png files
            if [[ $file == *.json ]] || [[ $file == *.png ]]; then
              continue
            fi

            # If the file still exists (hasn't been deleted/renamed), capture its contents
            if [ -f "$file" ]; then
              CONTENT=$(jq -Rs . < "$file")
              echo "{\"filename\": \"$file\", \"content\": $CONTENT}," >> original_files_temp.json
            fi
          done
          # Remove the trailing comma from the last file entry
          sed -i '$ s/,$//' original_files_temp.json
          echo "]}" >> original_files_temp.json

          # Temporarily store original files JSON for merging later

      - name: Display Processed Diff (Debug)
        run: cat original_files_temp.json

      - name: Get Diff
        run: |
          # Extract the diff from origin/main to HEAD.
          # Filter lines starting with '+' or '-' to focus on actual code changes only.
          # Exclude lines that are diff metadata like +++, ---.
          git diff origin/main...HEAD \
            | grep '^[+-]' \
            | grep -Ev '^(---|\+\+\+)' > code_changes_only.txt

          # Convert these changes into a JSON object
          jq -Rs '{diff: .}' code_changes_only.txt > diff.json

          # Merge diff.json with original_files_temp.json to consolidate data
          if [ -f original_files_temp.json ]; then
            jq -s '.[0] * .[1]' diff.json original_files_temp.json > combined.json
            mv combined.json diff.json
          fi

      - name: Display Processed Diff (Debug)
        run: cat diff.json

      - name: Analyze with OpenAI
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e  # Stop execution on any error

          # Extract the diff and original files from diff.json
          DIFF_CONTENT=$(jq -r '.diff' diff.json)
          ORIGINAL_FILES=$(jq -r '."original files"' diff.json)
    
          # Construct the prompt for the model
          PROMPT="Please review the following code changes for any obvious quality or security issues. Provide a brief report:\n\nDIFF:\n${DIFF_CONTENT}\n\nORIGINAL FILES:\n${ORIGINAL_FILES}"
    
          # Multi-line system message with escaped newlines
          SYSTEM_CONTENT="You are an expert code reviewer specializing in security, quality, and adherence to best practices. Your goal is to methodically analyze the provided code to ensure it meets the highest standards. Approach the review in a structured, step-by-step manner:\n1. Code Quality & Standards:\n• Validate that the code follows established coding standards, style guides, and naming conventions.\n• Check for consistent formatting, clear variable and function names, logical code organization, and adherence to language-specific best practices.\n2. Security & Vulnerability Analysis:\n• Inspect each code block for common vulnerabilities, including but not limited to:\n• SQL injection\n• Cross-Site Scripting (XSS)\n• Command injection\n• Insecure cryptographic operations\n• Verify robust input validation, proper output encoding, principle of least privilege in permissions, and the safe handling of sensitive data.\n• Identify any libraries or functions known to be insecure, and recommend safer alternatives.\n3. Fault Tolerance & Error Handling:\n• Confirm the code gracefully handles errors, exceptions, and unexpected inputs.\n• Check if proper try/catch blocks or equivalent mechanisms are in place.\n• Ensure that sensitive error details are not exposed to end users.\n4. Performance & Resource Management:\n• Evaluate the code for potential performance bottlenecks, unnecessary computations, or inefficient resource usage.\n• Suggest improvements to enhance efficiency without compromising readability or security.\n5. Step-by-Step Validation:\n• Examine the code incrementally, line by line or function by function.\n• Document each identified issue and provide explicit recommendations.\n• If code changes are suggested, present them in Markdown-formatted code blocks. Include straightforward comments and notes that make it easy for developers to understand and implement the improvements.\n\nResponse Guidelines:\n• Be both comprehensive and succinct in your final summary.\n• If recommendations are made, show sample improvements using Markdown code blocks. For example:\n// Before:\nString userInput = request.getParameter('username');\nString query = 'SELECT * FROM Users WHERE name = '' + userInput + ''';\n// Potentially vulnerable to SQL injection\n\n// After:\nString userInput = request.getParameter(\"username\");\nPreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM Users WHERE name = ?\");\nst.setString(1, userInput);\n// Parameterized query prevents SQL injection\n\nYour final response should be thorough, systematic, and leave no obvious security or quality issue unchecked. Provide clear, actionable recommendations to raise the overall standard of the code."
    
          # Create the request.json with the system and user messages
          jq -n --arg prompt "$PROMPT" --arg system_content "$SYSTEM_CONTENT" '{
            "model": "o1",
            "reasoning_effort": "high",
            "messages": [
              {
                "role": "system",
                "content": $system_content
              },
              {
                "role": "user",
                "content": $prompt
              }
            ]
          }' > request.json
    
          # Debug: print the request for verification
          cat request.json
    
          # Send request to OpenAI
          curl -sS https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @request.json > response.json
    
          # Check if response.json was created and contains valid data
          if [ ! -s response.json ]; then
            echo "No response from OpenAI API"
            exit 1
          fi

      - name: Debug OpenAI Response
        run: cat response.json

      - name: Extract Review Message
        id: extract_message
        run: |
          ASSISTANT_MSG=$(jq -r '.choices[0].message.content' response.json)
          if [ -z "$ASSISTANT_MSG" ] || [ "$ASSISTANT_MSG" = "null" ]; then
            echo "No valid assistant message found."
            exit 1
          fi

          {
            echo "message<<EOF"
            echo "$ASSISTANT_MSG"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Post comment to PR
        env:
          COMMENT: ${{ steps.extract_message.outputs.message }}
          GH_TOKEN: ${{ github.token }}
        run: |
          gh api \
            repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments \
            -f body="$COMMENT"
